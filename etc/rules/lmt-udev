#!/bin/sh -e


# /usr is not guaranteed to be mounted when udev starts
non_systemd_way() {
	if [ -e /lib/udev/hotplug.functions ]; then
		. /lib/udev/hotplug.functions
		wait_for_file /usr/sbin/laptop_mode
		exec /usr/sbin/laptop_mode "$@"
	else
		file=$1
		timeout=$2
		[ "$timeout" ] || timeout=120

		count=$timeout
		while [ $count != 0 ]; do
			[ -e "/usr/sbin/laptop_mode" ] && exec /usr/sbin/laptop_mode "$@" && return 0
			sleep 1
			count=$(($count - 1))
		done

		mesg "$file did not appear before the timeout!"
		exit 1
	fi
}


## For Debug only
#export LMT_DEBUG="/tmp/__lmt__debug.txt"
[ -z $LMT_DEBUG ] || rm -f $LMT_DEBUG
##

# Under systemd, we don't do synchronous operations, so we can run in the foreground;
# And we need also need to run in foreground, because forked children get kill immediately
# under systemd/udev

# The seconds "auto" evaluation is to determine if it is a standard execution;
# i.e. a reload/restart or a device plug/unplug

if [ -d /run/systemd/system ] && [ x$1 = xauto ]; then
	[ -z $LMT_DEBUG ] || echo "systemd is $PPID $$ $@" > $LMT_DEBUG
	exec systemctl --no-block reload-or-restart laptop-mode
else
	# Under sysvinit/upstart, we need to fork as we start the long-running
	# /usr/sbin/laptop_mode process.
	#
	# Also, if this happens during boot, we may want to wait until /usr is available
	#
	# On newer systemd/udev (232-3 over here), the behavior has changed in my tests.
	# Now, it'll immediately and quietly kill the process that is backgrounded
	# systemd is nice, but I hate when it tries to become a magician
	#
	# This stanza will also be called for device plug/unplug events

	[ -z $LMT_DEBUG ] || echo "regulard is $PPID $$ $@" > $LMT_DEBUG
	exec > /dev/null 2>/dev/null
	non_systemd_way "$@"
fi

exit 0
